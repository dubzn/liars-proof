{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 10650455514878738734,
  "abi": {
    "parameters": [
      {
        "name": "hand",
        "type": {
          "kind": "struct",
          "path": "Hand",
          "fields": [
            {
              "name": "card1_value",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            },
            {
              "name": "card1_suit",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            },
            {
              "name": "card2_value",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            },
            {
              "name": "card2_suit",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            },
            {
              "name": "card3_value",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            },
            {
              "name": "card3_suit",
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "_game_id",
        "type": { "kind": "integer", "sign": "unsigned", "width": 32 },
        "visibility": "public"
      },
      {
        "name": "hand_commitment",
        "type": { "kind": "field" },
        "visibility": "public"
      },
      {
        "name": "condition_id",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      },
      {
        "name": "comparator",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      },
      {
        "name": "value",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      },
      {
        "name": "suit",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "1236094297320043268": {
        "error_kind": "string",
        "string": "Hand commitment does not match"
      },
      "3635474097403129472": {
        "error_kind": "string",
        "string": "Hand does not meet the condition"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "7Z3djhtHDoXfZa5zUT+sv7zKYrFwEmdhwLADx1lgEeTdVzHcJYuc7cZgqDZVPHexrVF/OWyyOUfqPn8+/fL2pz/+/a93H379+PvTj//48+n9x5/ffH738cPlT38+xfjl737/7c2Hv//4++c3nz4//RiJ6Ientx9++fs/+/jrh6df371/+/RjjX/9IF6cQgpfX5xCOXhxb/Xra/vI86UpP/PS3MbXl1Ks15em5xHqRMj9+mJ65sVUJgOVHr998T9/eIrJnyA1pO2NaxhckOxQkDjfuGZxhhBa5laQgpa5FaSiZW4FaWiZW0E6BLkVZECQG0FSwFC9FcThpro7VJPDTXW/ZTxuqrstQ2iZW0Ecbqr7LeNxU91tGYeb6n7LYFNlgmBTvRUkO9xU9wWBp8oEgafKBIGnygQhtMytIPBUmSDwVJkg8FSZIA431f2Wcbip7rYMrbGpphA3hBTza1qG1thUFQVZY1NVFGSNTVVREPInyO5VhtbYVF8myO5VZo1NVbFl1thUFVtmjU1VsWXW2FT1WqY43FR3W6Y43FR3W6assale2mBDoJb2Bemjt8nwDUTsXwRZY1NVFIQgyK0ga2yqioKssakqCrLGpvoSQUbI5euLRyAhyBqbaql5Qygj8CvpGsunXhfUNZZPRUHWWD71xkJdY/ncHQsV+yQrOkGQW0H87ZMHY2GNfXJ/LPhbEQ+6YI0VUVEQf/vk/lhoa+yTu2Oh+VsR97ugwZ9kgvjbJw/GAjkYC7AcWdFhOTJBYDkyQRxYjg2W423ROyxHJggsRyaIA8uxw3JkRScIcisILEcmiAPLscNyZEWH5cgEgeV4K8hwYDkOWI6s6LAcmSCwHJkg5GAswHJkRYflyASB5cgEcWA5DliOt0WPAZ4jVwSmI1fEgesYA2xHXnaCIkwRGI9cEQfOYwywHnnZ4T1yRWA+MkWiA/cxLpIcpNgIi0QHaSoCA5IrQh5GAyxIXnZ4kFwRmJBcEQcuZFwk50exERYJ+tFUBDYkV8SDDblIfI9mIxAUYYrAhuSKeLAhF0nl0WwE2JBcEdiQTJFFgnn2R8MiYTuKjbBI2o6mIrAhuSLkYTTAhuRlhw3JFYENyRXxYEMuEo2j2AiLZONoKgIbkiviwYZcJPFGsxEIijBFYENyRTzYkIsE2Wg2AmxIrghsSKbIIlk2+6NhkXwaxUZAQI1QBDYkV4Q8jAbYkLzssCG5IrAhuSIebEhEz/CyI3tGKAIbkiviwYZE/IwoO0ERpghsSK6IBxsSETSi7LAhuSKwIZkiHlJoImJoRNlhQ3JFYENyRcjDaIANycsOG5IrAhuSK+LBhkQcDS878miEIrAhuSIebEhE0oiyExRhisCG5Ip4sCERSyPKDhuSKwIbkiniIZkmIppGlB02JFcENiRXhDyMBtiQvOywIbkisCG5Ih5sSETUsLInRNQIRWBDckUc2JAJETWi7ARFmCKwIbkiDmzIhIgaUXbYkFwR2JBMEQ8RNQkRNaLssCG5IrAhuSLkYTTAhuRlhw3JFYENyRVxYEMmRNTwsiOiRigCG5Ir4sGGRESNKDtBEaYIbEiuiAcbEhE1ouywIbkisCGZIh4iahIiakTZYUNyRWBDckXIw2iADcnLDhuSKwIbkiviwYZERA0vOyJqhCKwIbkiHmxIRNSIshMUYYrAhuSKeLAhEVEjyg4bkisCG5Ip4iGiJiGiRpQdNiRXBDYkV4Q8jAbYkLzssCG5IrAhuSIebEhE1PCyI6JGKAIbkiviwYZERI0oO0ERpghsSK6IBxsSETWi7LAhuSKwIZkiHiJqEiJqRNlhQ3JFYENyRcjDaIANycsOG5IrAhuSK+LBhkREDS87ImqEIrAhuSIebMg1ImpypO1tcyx9v+yXU2R7MZUehSLkT5Ea0vbGNQyhyBKb5QsVifONa5bnyBKbpWrXLLFZqnbNEpulatcssYZqds0aeTaaXbNG+I1m16wRfqPaNdhZuSIERZgiDnfWA0Uc7qwH1xqPO+v+tcbhznrQNQ531t2uyWvE6ih2TV4jVkexa/IasTqqXeNwZz3oGkLXMEWws3JF4LNyRRzurAeKePRZ9681HnfW3WvNGoE9ml2zRrqPZteske6j2jXwWbkihK5hiuC7AVyRNXbWXLfvRuXc2uu6Zo2dVVORNXZWTUXW2FkVFVkjN+hliuxfa9bIDXqhIrvXmjVyg1S7Zo2dVbNrCF3DFFljZ9XsGoc760HXONxZD7pGY2ftG06KKX8PRS5FqbMo+XVugEoi0YMpst81KolEj6bIbteoxBct1TUq8UVrdU1G1zBFCF3DFClQhClSoQhTpGGyMkUc7qwHk9XhzrrfNeRxZ93tGnK4s+53DTncWQ+6xuPOut81hK5himBn5YpgZ+WKONxZDxSBz8oVgc/KFCnwWbki8Fm5IvBZuSLwWbkihK5hijjcWQ+6xuHOetA1a+ysKcQNIcX8uq5ZY2fVVGSNnVVRkbrGzqqpyBo764sU2b/W1DV21pcpsnutqWvsrJpdQ+gapsgaO6tm16yxs2p2jcOd9aBrHO6sB12zxs6q91D83NbYWTUVWWNn1VRkjZ1VU5E1dlZNRcidIvvhGrmtsbPuhmvktsYaqtkIa6yhmoqssYZqjoY11tD90dCxWbKyd2yWXBF/m+XBaOhrbJYHo4HQCKzsayyLmor42yyPRsMam+XBaPC3LB41AjxLpsjwt1kejIaxxma5PxoGbEhedtiQXBHCaGCKeLAhB2xIXnbYkFwR2JBcEQc2JAXYkLdlpwAbkisCG5Ir4sCGpEBoBFZ22JBcEdiQXBEHNiQF2JC87LAhmSIRNiRXxIENSRE2JC87bEiuCGE0MEUc2JAUYUPyssOG5IrAhuSKeLAhE2xIVvYEG5IrAhuSK+LBhlSJL1qrEWBDckVgQ3JFPNiQiyQSaTYCbEimyCKJRIqjYZFEov3RsEjIkGYjwIbkihBGA1PEgw25SG6QZiPAhuSKwIbkiniwIReJAlJshEWigDQVgQ3JFfFgQy6S7qPZCLAhuSKwIbkiHmzIRQJ7NBsBNiRTZJHAHsXRsEhgz/5oWCSDR7MRYENyRQijgSniwYZcJFZHsxFgQ3JFYENyRTzYkIsk5Sg2wiJJOZqKwIbkiniwIRcJv9FsBNiQXBHYkFwRDzbkInk2mo0AG5Ip4jDP5mA0LJJnsz8aEFEjyg4bkitCGA1MEQ82JCJqRNlhQ3JFYENyRTzYkIio4WVHRI1QBDYkV8SDDYmIGlF22JBcEdiQXBEPNiQiakTZYUMyRRBRIxTxYEMiokaUHTYkV4QwGpgiHmxIRNSIssOG5IrAhuSKOLAhCyJqWNkLImqEIrAhuSIObMgSCI3Ayg4bkisCG5Ir4sCGLIioEWWHDckUQUSNUMSBDVkQUSPKDhuSK0IYDUwRBzZkQUSNKDtsSK4IbEiuiAcbEhE1vOyIqBGKwIbkiniwIRFRI8oOG5IrAhuSK+LBhkREjSg7bEimCCJqhCIebEhE1Iiyw4bkihBGA1PEgw2JiBpRdtiQXBHYkFwRDzYkImp42RFRIxSBDckV8WBDIqJGlB02JFcENiRXxIMNiYgaUXbYkEwRRNQIRTzYkIioEWWHDckVIYwGpogHGxIRNaLssCG5IrAhuSIebEhE1PCyI6JGKAIbkiviwYZERI0oO2xIrghsSK6IBxsSETWi7LAhmSKIqBGKeLAhEVEjyg4bkitCGA1MEQ82JCJqRNlhQ3JFYENyRTzYkIio4WVHRI1QBDYkV8SDDYmIGlF22JBcEdiQXBEPNiQiakTZYUMyRRBRIxTxYEMiokaUHTYkV4QwGpgiHmxIRNSIssOG5IrAhuSKOLAh6xoRNTnS9rY5lr5f9sspsr2YLqajUGSJZfFlitSQtjeuYQhFltgsX6hInG9cszxHltgsVbuG0DVMkSU2S9WuWWINVe2aJdZQ1a5ZYg1V7Zol1lDNrlkj/EZVEYc764EiDnfWA0Uc7qz715o1knI0rzVrJOWodo3DnfWgazzurPtd43BnPegahzvrfteskcGj2TVrZPBods0aGTyqisBn5YoQFGGKePRZ9681HnfW/WuNw531oGs8+qz7XeNxZ93tmjXSfTS7Zo10H82uWSMKSLVr1thZc90Qcm7tdV1DUIQpssbOqqnIGjurpiJr7KwvUuTgWrPGzvoyRfavNWvsrIpds0bIkGbXrBEypNk1a4QMqXaNw531oGsIXcMUUdhZY553Z8RK3774yxGe3wFL3aSJF5Pm4Aglbf8PqfQkjtDufoR+9yMMhSOMeU/I5fqw/2IKZaswhdsK/43zf7JXvhtOtIWTbOHk74cTQxc4ZAunnIwTY584ty/+glNt4TRbOP1snJKul90mcIYpnBps4URbOMkWztlTOfaJk+QYrGQLp9jCqbZwzp7K6fpLQspiha/dFs4whdOCLZyzp3KiK04TV/SWbOFkWzhkC+fsqZy+GYNDjMFWbeE0WzjdFs4whdNtTeUebeEkWzjZ1OreyRZOsYWjMJUvNsiG0+T629vdj9DvfgSFcdhm06TWDj5qoDKmC1ZT5Tgj2MKJtnCSLZxsC4dOxrmYFRNnSJxiC6fawmm2cPrJOC1sH0bS5ecEzrCE00KwhRNt4Zw9lVuep3KrVeBkWzhkC6fYwjl7Krd2PZW7PJWbLZxuC2eYwonBFk60hZNs4WRbOGdP5R7ihtNTEDjFFk61hdNs4WhM5b59vSL1LM/Oce8jpHD3I8S7H0FhwvUStiOMcHBalEAbTgmtC5xsC4ds4RRbONUWTjsZJ8btnUsksZWnbgtnmMLJwRZOPBtnPuW/xCqmck62cLItHLKFc/ZUjn1zA0qKJHCqLZxmC6fbwjl7KqdUJk7mH3c2CrZwoi2cZAsn28IhWzjFFk61hXP2VL5+F6+kKlZ36rZwhimcEmzhKEzlMe+MSaOIjUrjnrODI+S7H4HufgSFCTfadlrkENrBaUHzEUOFbr9PK188ct6+hDUyJcFeH5i9PTB7f2D2YZs9XdnFzNS4m+27sccHZk8PzJ5PZi9xwyklt1f1qsYdeN+NvTwwe31g9mabfbdX+wOzj8dlb2dfV8v1I6hSs8CJtnCSLZxsC+f0a1SbOPXod/CDWdnKA7PXB2ZvD8zebbPvzvnxuOw9PDD72Re0GufHZeydv+AkWzjZFg7Zwim2cKotnGYLp9vCOXveV4oTR66KI9jCibZwki2c10/lHFKaOFVsUgo3iR4dodz9CPXuR2gKR2jbRptjOHhx6XnuPf2Z06Lbwhkn4wzaOqyMwr+I1BXuzlTFibZwki2cfC5ODWF75xrEvRw9kC2cYgun2sJptnC6LZxhCicGWzjxbJxpTtRQssBJtnCyLRyyhaMwlWOiiTPk2VnvfoR29yP0ux9BYcKleWtnTv3gSw6X39W2LxNWEqZ0V7iH8oU480lWlbrYrBRuuFTFSbZwsi0csoVTbOHUk3HKfEhJLVU2erOF023hDFM4+eypXOaDJmoRD5roOdrCSbZwsi2cs6dynV8nqpXEvpOLLZxqC6fZwjl7KtdSJo54+mvPwxQOBVs40RZOsoWTbeGQLZxiC+f0qTwfUV3lwyA7nT2VW77i1Chwui2cYQqnBFs40RZOsoVz9lRuMxW1tt4FDtnCOXsqXz5R2HDks8l6qbZwmi2cbgvn7KncZxJm7eKZuL0GWzjRFk6yhZNt4ZAtnGILp9rCOX0q9/l51ojiN4nabeEMUzgt2MI5eyqP60fkg8QnNi3Zwsm2cMgWTrGFU23hNFs43RbO2VP5+u36Oob4tK+fPJXb9VtmLeQicOLZOPPZWE1+jb33ZAvn5KncYtouoU2G2PdOtnCKLZxqC6fZwum2cIYpnBFs4Zw9lVPYbp9pSX4VeSRbONkWDtnCKbZwqi2cZgun28I5eyonyhNHrF8jBFs40RZOsoWjMZXH9uKcqYkj0N2PUO5+hHr3IyhMuFy2KZEplIPTgtpmGbcSg8DptnCGKRyNe840caItnGQLJ5+MU0qcOF00usY9Z5o4xRZOtYVz9lQuYzNFW01d4HRbOMMUTgq2cOLpp3K44gyBc/ZUrnTFEfe6jpRt4ZAtnGILp9rCabZwzp7Kdb5zq70KnGEKJwdbONEWjsJUpjSfC0ZNrL8at74dHIHufoRy9yMoTDjq05Up6eD5bO3yC/92WgzxScLQuOdME6fbwhmmcDTuOdPEibZw0tk4M8y7hyT8To17zjRxyBZOsYVz8lS+MLSJU+Wp3GzhdFs4wxROOX0q929wxKlc4tnqzOdS9TAkTrKFk23hkC2cYgun2sI5eyrHsN0n3WOWc6fbwhmmcGqwhaMwlQvNJzyXIVxgjdvIDo6Q734EuvsRFCZcDdt383JtB5EePc+HC3QqB+982YpnZgwVyV4fmL09MHt/YPbxuOwaN6h9N/Zsmr3TZB8k2OmB2W3P93122/N9n932fN9ntz3fd9k1boh6EXsJk71IH61nWzhkC6fYwqm2cJotnLOnQsnT1pMBqaOfvciV+V3HXobAGcEWTrSFk2zhnD2V67yLpNcsPgIfZ0/la0RZr1VYM6PYwqm2cJotnG4Lx9RUjiGYGssXHlNz+cJjal2+8Jjaly88phbmC4/GbJ6f/OdGz5wS9f6HaPc/RL//IRRmXZuPD8s9Hn2iMuZjgkdI8eDX5ErzxbUEAa9xI9X3g4+PDJ8eGT4/Mjw9MnwzDT8f3Tvkd60v8P2R4W3P+X34ZHvOH8DbnvMH8Lbn/AF8PRd+hHqFF3FhF55mjKcb4xm2eHIwxhON8aSzecb2S+iIqUiek/e6EfOcP7E8w0PGeIoxnmqM5+z5HOdDQ0cc0ifJZ8/nNH2bkZL0CvKwxUPBGE80xpOM8Ribz2RsPpOx+UzG9mcytj+Tsf2ZjO3P5fTPrfY/dyjRGM/Zd1Ht3s1w+cfTH6qy93CDC4/CfNZ71uGFR2E+X29GyjEcvLiG6zPuQ5HXU4U7qdL1ufX58onW/ovL9WPzyzGe4Xn9fE59PoUojXDQXyXR1owl1S55Xj+fU4vbIVI76nfq82SjnqT7rXAzVSrzW6ap0sH5TLFs5w9FEckZg8LdVLo80RjP8/O5znuRYi23P3X5w0+f3r1//+7f/3r/8ec3n999/PD75Ucvf/2fN5/evfnp/duvf/z1jw8/f/Ovn//72/Yv28//9unjz29/+ePT27/f6cu/Xd7+fw==",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
      "path": "std/hash/poseidon/bn254/perm.nr"
    },
    "23": {
      "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      "path": "std/hash/poseidon/bn254.nr"
    },
    "24": {
      "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n",
      "path": "std/hash/poseidon/mod.nr"
    },
    "61": {
      "source": "use std::hash::poseidon;\n\n// Condition IDs aligned with contract specification\nglobal CONDITION_CARDS_SUM_COMPARATOR_THAN_X: u8 = 1;\nglobal CONDITION_EXACTLY_X_CARDS_OF_VALUE_Y: u8 = 2;\nglobal CONDITION_EXACTLY_X_CARDS_OF_SUIT_Y: u8 = 3;\nglobal CONDITION_EXACTLY_X_PAIRS: u8 = 4;\nglobal CONDITION_EXACTLY_X_ODDS: u8 = 5;\nglobal CONDITION_EXACTLY_X_COMPARATOR_THAN_SPECIFIC_VALUE: u8 = 6;\nglobal CONDITION_EXACTLY_X_DISTINCT_VALUES: u8 = 7;\nglobal CONDITION_EXACTLY_X_DISTINCT_SUITS: u8 = 8;\nglobal CONDITION_HIGHEST_CARD_COMPARATOR_THAN_X: u8 = 9;\nglobal CONDITION_LOWEST_CARD_COMPARATOR_THAN_X: u8 = 10;\n\n// Comparator values\nglobal LESS_THAN: u8 = 1;\nglobal GREATER_THAN: u8 = 2;\nglobal EQUAL_TO: u8 = 3;\n\n// Suit values\nglobal CLUBS: u8 = 1;\nglobal SPADES: u8 = 2;\nglobal DIAMONDS: u8 = 3;\nglobal HEARTS: u8 = 4;\n\n// Private inputs - the actual cards\n// Represented as [value1, suit1, value2, suit2, value3, suit3]\nstruct Hand {\n    card1_value: u8,\n    card1_suit: u8,\n    card2_value: u8,\n    card2_suit: u8,\n    card3_value: u8,\n    card3_suit: u8,\n}\n\n// Main circuit that validates a player's hand meets the condition\nfn main(\n    // Private inputs (known only to the player)\n    hand: Hand,\n    // Public inputs (known to everyone)\n    _game_id: pub u32,\n    hand_commitment: pub Field,\n    condition_id: pub u8,\n    comparator: pub u8,\n    value: pub u8,\n    suit: pub u8,\n) {\n    // 1. Verify that the hand matches the commitment\n    verify_hand_commitment(hand, hand_commitment);\n\n    // 2. Validate the hand meets the condition\n    let meets_condition = validate_condition(hand, condition_id, comparator, value, suit);\n    assert(meets_condition, \"Hand does not meet the condition\");\n}\n\n// Verify that the hand commitment matches the actual cards\nfn verify_hand_commitment(hand: Hand, commitment: Field) {\n    let card1 = pack_card(hand.card1_value, hand.card1_suit);\n    let card2 = pack_card(hand.card2_value, hand.card2_suit);\n    let card3 = pack_card(hand.card3_value, hand.card3_suit);\n\n    let temp = poseidon::bn254::hash_2([card1, card2]);\n    let computed_hash = poseidon::bn254::hash_2([temp, card3]);\n\n    assert(computed_hash == commitment, \"Hand commitment does not match\");\n}\n\n// Pack a card (value, suit) into a single Field element\nfn pack_card(value: u8, suit: u8) -> Field {\n    (value as Field) * 256 + (suit as Field)\n}\n\n// Main validation function that routes to specific condition checks\nfn validate_condition(hand: Hand, condition_id: u8, comparator: u8, value: u8, suit: u8) -> bool {\n    if condition_id == CONDITION_CARDS_SUM_COMPARATOR_THAN_X {\n        validate_sum_comparator(hand, comparator, value)\n    } else if condition_id == CONDITION_EXACTLY_X_CARDS_OF_VALUE_Y {\n        validate_exactly_x_cards_of_value_y(hand, value, suit)\n    } else if condition_id == CONDITION_EXACTLY_X_CARDS_OF_SUIT_Y {\n        validate_exactly_x_cards_of_suit_y(hand, value, suit)\n    } else if condition_id == CONDITION_EXACTLY_X_PAIRS {\n        validate_exactly_x_pairs(hand, value)\n    } else if condition_id == CONDITION_EXACTLY_X_ODDS {\n        validate_exactly_x_odds(hand, value)\n    } else if condition_id == CONDITION_EXACTLY_X_COMPARATOR_THAN_SPECIFIC_VALUE {\n        validate_exactly_x_comparator_than_specific_value(hand, value, comparator, suit)\n    } else if condition_id == CONDITION_EXACTLY_X_DISTINCT_VALUES {\n        validate_exactly_x_distinct_values(hand, value)\n    } else if condition_id == CONDITION_EXACTLY_X_DISTINCT_SUITS {\n        validate_exactly_x_distinct_suits(hand, value)\n    } else if condition_id == CONDITION_HIGHEST_CARD_COMPARATOR_THAN_X {\n        validate_highest_card_comparator_than_x(hand, comparator, value)\n    } else if condition_id == CONDITION_LOWEST_CARD_COMPARATOR_THAN_X {\n        validate_lowest_card_comparator_than_x(hand, comparator, value)\n    } else {\n        false\n    }\n}\n\n// Condition 1: Cards sum comparator than X\n// COMPARATOR = {1, 2, 3} (<, >, =)\n// VALUE = range {10, 20}\nfn validate_sum_comparator(hand: Hand, comparator: u8, threshold: u8) -> bool {\n    let sum = hand.card1_value + hand.card2_value + hand.card3_value;\n\n    if comparator == LESS_THAN {\n        sum < threshold\n    } else if comparator == GREATER_THAN {\n        sum > threshold\n    } else if comparator == EQUAL_TO {\n        sum == threshold\n    } else {\n        false\n    }\n}\n\n// Condition 2: Exactly X cards of value Y\n// QUANTITY = range {1, 2, 3}\n// VALUE = range {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\nfn validate_exactly_x_cards_of_value_y(hand: Hand, quantity: u8, target_value: u8) -> bool {\n    let mut matches = 0;\n    if hand.card1_value == target_value {\n        matches += 1;\n    }\n    if hand.card2_value == target_value {\n        matches += 1;\n    }\n    if hand.card3_value == target_value {\n        matches += 1;\n    }\n    matches == quantity\n}\n\n// Condition 3: Exactly X cards of suit Y\n// QUANTITY = range {1, 2, 3}\n// SUIT = range {1, 2, 3, 4}\nfn validate_exactly_x_cards_of_suit_y(hand: Hand, quantity: u8, target_suit: u8) -> bool {\n    let mut matches = 0;\n    if hand.card1_suit == target_suit {\n        matches += 1;\n    }\n    if hand.card2_suit == target_suit {\n        matches += 1;\n    }\n    if hand.card3_suit == target_suit {\n        matches += 1;\n    }\n    matches == quantity\n}\n\n// Condition 4: Exactly X pairs (even cards)\n// QUANTITY = range {1, 2, 3}\nfn validate_exactly_x_pairs(hand: Hand, quantity: u8) -> bool {\n    let mut even_count = 0;\n    if is_even(hand.card1_value) {\n        even_count += 1;\n    }\n    if is_even(hand.card2_value) {\n        even_count += 1;\n    }\n    if is_even(hand.card3_value) {\n        even_count += 1;\n    }\n    even_count == quantity\n}\n\n// Condition 5: Exactly X odds (odd cards)\n// QUANTITY = range {1, 2, 3}\nfn validate_exactly_x_odds(hand: Hand, quantity: u8) -> bool {\n    let mut odd_count = 0;\n    if !is_even(hand.card1_value) {\n        odd_count += 1;\n    }\n    if !is_even(hand.card2_value) {\n        odd_count += 1;\n    }\n    if !is_even(hand.card3_value) {\n        odd_count += 1;\n    }\n    odd_count == quantity\n}\n\n// Condition 6: Exactly X cards comparator than specific value\n// QUANTITY = range {1, 2, 3}\n// COMPARATOR = {1, 2, 3} (<, >, =)\n// VALUE = range {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\nfn validate_exactly_x_comparator_than_specific_value(\n    hand: Hand,\n    quantity: u8,\n    comparator: u8,\n    threshold: u8,\n) -> bool {\n    let mut matches = 0;\n\n    if comparator == LESS_THAN {\n        if hand.card1_value < threshold {\n            matches += 1;\n        }\n        if hand.card2_value < threshold {\n            matches += 1;\n        }\n        if hand.card3_value < threshold {\n            matches += 1;\n        }\n    } else if comparator == GREATER_THAN {\n        if hand.card1_value > threshold {\n            matches += 1;\n        }\n        if hand.card2_value > threshold {\n            matches += 1;\n        }\n        if hand.card3_value > threshold {\n            matches += 1;\n        }\n    } else if comparator == EQUAL_TO {\n        if hand.card1_value == threshold {\n            matches += 1;\n        }\n        if hand.card2_value == threshold {\n            matches += 1;\n        }\n        if hand.card3_value == threshold {\n            matches += 1;\n        }\n    }\n\n    matches == quantity\n}\n\n// Condition 7: Exactly X distinct values\n// QUANTITY = range {1, 2, 3}\nfn validate_exactly_x_distinct_values(hand: Hand, quantity: u8) -> bool {\n    let mut distinct = 1; // Card 1 is always counted\n\n    if hand.card2_value != hand.card1_value {\n        distinct += 1;\n    }\n\n    if (hand.card3_value != hand.card1_value) & (hand.card3_value != hand.card2_value) {\n        distinct += 1;\n    }\n\n    distinct == quantity\n}\n\n// Condition 8: Exactly X distinct suits\n// QUANTITY = range {1, 2, 3}\nfn validate_exactly_x_distinct_suits(hand: Hand, quantity: u8) -> bool {\n    let mut distinct_suits = 1; // Card 1 suit is always counted\n\n    if hand.card2_suit != hand.card1_suit {\n        distinct_suits += 1;\n    }\n\n    if (hand.card3_suit != hand.card1_suit) & (hand.card3_suit != hand.card2_suit) {\n        distinct_suits += 1;\n    }\n\n    distinct_suits == quantity\n}\n\n// Condition 9: Highest card comparator than X\n// COMPARATOR = {1, 2, 3} (<, >, =)\n// VALUE = range {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\nfn validate_highest_card_comparator_than_x(hand: Hand, comparator: u8, threshold: u8) -> bool {\n    let max_val = max_of_three(hand.card1_value, hand.card2_value, hand.card3_value);\n\n    if comparator == LESS_THAN {\n        max_val < threshold\n    } else if comparator == GREATER_THAN {\n        max_val > threshold\n    } else if comparator == EQUAL_TO {\n        max_val == threshold\n    } else {\n        false\n    }\n}\n\n// Condition 10: Lowest card comparator than X\n// COMPARATOR = {1, 2, 3} (<, >, =)\n// VALUE = range {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\nfn validate_lowest_card_comparator_than_x(hand: Hand, comparator: u8, threshold: u8) -> bool {\n    let min_val = min_of_three(hand.card1_value, hand.card2_value, hand.card3_value);\n\n    if comparator == LESS_THAN {\n        min_val < threshold\n    } else if comparator == GREATER_THAN {\n        min_val > threshold\n    } else if comparator == EQUAL_TO {\n        min_val == threshold\n    } else {\n        false\n    }\n}\n\n// Helper: Check if a value is even\nfn is_even(value: u8) -> bool {\n    (value % 2) == 0\n}\n\n// Helper: Find max of three values\nfn max_of_three(a: u8, b: u8, c: u8) -> u8 {\n    let max_ab = if a > b { a } else { b };\n    if max_ab > c {\n        max_ab\n    } else {\n        c\n    }\n}\n\n// Helper: Find min of three values\nfn min_of_three(a: u8, b: u8, c: u8) -> u8 {\n    let min_ab = if a < b { a } else { b };\n    if min_ab < c {\n        min_ab\n    } else {\n        c\n    }\n}\n\n// ============================================================================\n// TESTS\n// ============================================================================\n\n// Test Condition 1: Cards sum comparator than X\n#[test]\nfn test_condition_1_sum_less_than() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 3,\n        card2_suit: 2,\n        card3_value: 4,\n        card3_suit: 3,\n    };\n    // Sum is 9\n    assert(validate_sum_comparator(hand, LESS_THAN, 10));\n    assert(!validate_sum_comparator(hand, LESS_THAN, 9));\n}\n\n#[test]\nfn test_condition_1_sum_greater_than() {\n    let hand = Hand {\n        card1_value: 10,\n        card1_suit: 1,\n        card2_value: 8,\n        card2_suit: 2,\n        card3_value: 7,\n        card3_suit: 3,\n    };\n    // Sum is 25\n    assert(validate_sum_comparator(hand, GREATER_THAN, 20));\n    assert(!validate_sum_comparator(hand, GREATER_THAN, 25));\n}\n\n#[test]\nfn test_condition_1_sum_equal_to() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: 1,\n        card2_value: 5,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    // Sum is 15\n    assert(validate_sum_comparator(hand, EQUAL_TO, 15));\n    assert(!validate_sum_comparator(hand, EQUAL_TO, 14));\n}\n\n// Test Condition 2: Exactly X cards of value Y\n#[test]\nfn test_condition_2_one_card_of_value() {\n    let hand = Hand {\n        card1_value: 7,\n        card1_suit: 1,\n        card2_value: 3,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_cards_of_value_y(hand, 1, 7));\n    assert(!validate_exactly_x_cards_of_value_y(hand, 2, 7));\n}\n\n#[test]\nfn test_condition_2_two_cards_of_value() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: 1,\n        card2_value: 5,\n        card2_suit: 2,\n        card3_value: 8,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_cards_of_value_y(hand, 2, 5));\n    assert(!validate_exactly_x_cards_of_value_y(hand, 1, 5));\n}\n\n#[test]\nfn test_condition_2_three_cards_of_value() {\n    let hand = Hand {\n        card1_value: 11,\n        card1_suit: 1,\n        card2_value: 11,\n        card2_suit: 2,\n        card3_value: 11,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_cards_of_value_y(hand, 3, 11));\n    assert(!validate_exactly_x_cards_of_value_y(hand, 2, 11));\n}\n\n// Test Condition 3: Exactly X cards of suit Y\n#[test]\nfn test_condition_3_one_card_of_suit() {\n    let hand = Hand {\n        card1_value: 7,\n        card1_suit: HEARTS,\n        card2_value: 3,\n        card2_suit: CLUBS,\n        card3_value: 5,\n        card3_suit: SPADES,\n    };\n    assert(validate_exactly_x_cards_of_suit_y(hand, 1, HEARTS));\n    assert(!validate_exactly_x_cards_of_suit_y(hand, 2, HEARTS));\n}\n\n#[test]\nfn test_condition_3_two_cards_of_suit() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: DIAMONDS,\n        card2_value: 8,\n        card2_suit: DIAMONDS,\n        card3_value: 3,\n        card3_suit: CLUBS,\n    };\n    assert(validate_exactly_x_cards_of_suit_y(hand, 2, DIAMONDS));\n    assert(!validate_exactly_x_cards_of_suit_y(hand, 3, DIAMONDS));\n}\n\n#[test]\nfn test_condition_3_three_cards_of_suit() {\n    let hand = Hand {\n        card1_value: 1,\n        card1_suit: SPADES,\n        card2_value: 9,\n        card2_suit: SPADES,\n        card3_value: 13,\n        card3_suit: SPADES,\n    };\n    assert(validate_exactly_x_cards_of_suit_y(hand, 3, SPADES));\n    assert(!validate_exactly_x_cards_of_suit_y(hand, 2, SPADES));\n}\n\n// Test Condition 4: Exactly X pairs (even cards)\n#[test]\nfn test_condition_4_one_even_card() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 3,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_pairs(hand, 1));\n    assert(!validate_exactly_x_pairs(hand, 2));\n}\n\n#[test]\nfn test_condition_4_two_even_cards() {\n    let hand = Hand {\n        card1_value: 4,\n        card1_suit: 1,\n        card2_value: 8,\n        card2_suit: 2,\n        card3_value: 7,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_pairs(hand, 2));\n    assert(!validate_exactly_x_pairs(hand, 1));\n}\n\n#[test]\nfn test_condition_4_three_even_cards() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 6,\n        card2_suit: 2,\n        card3_value: 10,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_pairs(hand, 3));\n    assert(!validate_exactly_x_pairs(hand, 2));\n}\n\n// Test Condition 5: Exactly X odds (odd cards)\n#[test]\nfn test_condition_5_one_odd_card() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: 1,\n        card2_value: 4,\n        card2_suit: 2,\n        card3_value: 6,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_odds(hand, 1));\n    assert(!validate_exactly_x_odds(hand, 2));\n}\n\n#[test]\nfn test_condition_5_two_odd_cards() {\n    let hand = Hand {\n        card1_value: 1,\n        card1_suit: 1,\n        card2_value: 7,\n        card2_suit: 2,\n        card3_value: 8,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_odds(hand, 2));\n    assert(!validate_exactly_x_odds(hand, 3));\n}\n\n#[test]\nfn test_condition_5_three_odd_cards() {\n    let hand = Hand {\n        card1_value: 3,\n        card1_suit: 1,\n        card2_value: 9,\n        card2_suit: 2,\n        card3_value: 11,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_odds(hand, 3));\n    assert(!validate_exactly_x_odds(hand, 2));\n}\n\n// Test Condition 6: Exactly X cards comparator than specific value\n#[test]\nfn test_condition_6_less_than() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 4,\n        card2_suit: 2,\n        card3_value: 8,\n        card3_suit: 3,\n    };\n    // 2 cards are less than 5\n    assert(validate_exactly_x_comparator_than_specific_value(hand, 2, LESS_THAN, 5));\n    assert(!validate_exactly_x_comparator_than_specific_value(hand, 1, LESS_THAN, 5));\n}\n\n#[test]\nfn test_condition_6_greater_than() {\n    let hand = Hand {\n        card1_value: 10,\n        card1_suit: 1,\n        card2_value: 12,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    // 2 cards are greater than 7\n    assert(validate_exactly_x_comparator_than_specific_value(hand, 2, GREATER_THAN, 7));\n    assert(!validate_exactly_x_comparator_than_specific_value(hand, 3, GREATER_THAN, 7));\n}\n\n#[test]\nfn test_condition_6_equal_to() {\n    let hand = Hand {\n        card1_value: 7,\n        card1_suit: 1,\n        card2_value: 7,\n        card2_suit: 2,\n        card3_value: 9,\n        card3_suit: 3,\n    };\n    // 2 cards are equal to 7\n    assert(validate_exactly_x_comparator_than_specific_value(hand, 2, EQUAL_TO, 7));\n    assert(!validate_exactly_x_comparator_than_specific_value(hand, 1, EQUAL_TO, 7));\n}\n\n// Test Condition 7: Exactly X distinct values\n#[test]\nfn test_condition_7_one_distinct_value() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: 1,\n        card2_value: 5,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_distinct_values(hand, 1));\n    assert(!validate_exactly_x_distinct_values(hand, 2));\n}\n\n#[test]\nfn test_condition_7_two_distinct_values() {\n    let hand = Hand {\n        card1_value: 3,\n        card1_suit: 1,\n        card2_value: 3,\n        card2_suit: 2,\n        card3_value: 8,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_distinct_values(hand, 2));\n    assert(!validate_exactly_x_distinct_values(hand, 1));\n}\n\n#[test]\nfn test_condition_7_three_distinct_values() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 7,\n        card2_suit: 2,\n        card3_value: 11,\n        card3_suit: 3,\n    };\n    assert(validate_exactly_x_distinct_values(hand, 3));\n    assert(!validate_exactly_x_distinct_values(hand, 2));\n}\n\n// Test Condition 8: Exactly X distinct suits\n#[test]\nfn test_condition_8_one_distinct_suit() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: CLUBS,\n        card2_value: 7,\n        card2_suit: CLUBS,\n        card3_value: 11,\n        card3_suit: CLUBS,\n    };\n    assert(validate_exactly_x_distinct_suits(hand, 1));\n    assert(!validate_exactly_x_distinct_suits(hand, 2));\n}\n\n#[test]\nfn test_condition_8_two_distinct_suits() {\n    let hand = Hand {\n        card1_value: 3,\n        card1_suit: HEARTS,\n        card2_value: 8,\n        card2_suit: HEARTS,\n        card3_value: 5,\n        card3_suit: DIAMONDS,\n    };\n    assert(validate_exactly_x_distinct_suits(hand, 2));\n    assert(!validate_exactly_x_distinct_suits(hand, 1));\n}\n\n#[test]\nfn test_condition_8_three_distinct_suits() {\n    let hand = Hand {\n        card1_value: 1,\n        card1_suit: CLUBS,\n        card2_value: 9,\n        card2_suit: SPADES,\n        card3_value: 13,\n        card3_suit: DIAMONDS,\n    };\n    assert(validate_exactly_x_distinct_suits(hand, 3));\n    assert(!validate_exactly_x_distinct_suits(hand, 2));\n}\n\n// Test Condition 9: Highest card comparator than X\n#[test]\nfn test_condition_9_highest_less_than() {\n    let hand = Hand {\n        card1_value: 3,\n        card1_suit: 1,\n        card2_value: 7,\n        card2_suit: 2,\n        card3_value: 5,\n        card3_suit: 3,\n    };\n    // Highest is 7, should be less than 10\n    assert(validate_highest_card_comparator_than_x(hand, LESS_THAN, 10));\n    assert(!validate_highest_card_comparator_than_x(hand, LESS_THAN, 7));\n}\n\n#[test]\nfn test_condition_9_highest_greater_than() {\n    let hand = Hand {\n        card1_value: 2,\n        card1_suit: 1,\n        card2_value: 11,\n        card2_suit: 2,\n        card3_value: 6,\n        card3_suit: 3,\n    };\n    // Highest is 11, should be greater than 9\n    assert(validate_highest_card_comparator_than_x(hand, GREATER_THAN, 9));\n    assert(!validate_highest_card_comparator_than_x(hand, GREATER_THAN, 11));\n}\n\n#[test]\nfn test_condition_9_highest_equal_to() {\n    let hand = Hand {\n        card1_value: 4,\n        card1_suit: 1,\n        card2_value: 13,\n        card2_suit: 2,\n        card3_value: 9,\n        card3_suit: 3,\n    };\n    // Highest is 13\n    assert(validate_highest_card_comparator_than_x(hand, EQUAL_TO, 13));\n    assert(!validate_highest_card_comparator_than_x(hand, EQUAL_TO, 12));\n}\n\n// Test Condition 10: Lowest card comparator than X\n#[test]\nfn test_condition_10_lowest_less_than() {\n    let hand = Hand {\n        card1_value: 8,\n        card1_suit: 1,\n        card2_value: 3,\n        card2_suit: 2,\n        card3_value: 10,\n        card3_suit: 3,\n    };\n    // Lowest is 3, should be less than 5\n    assert(validate_lowest_card_comparator_than_x(hand, LESS_THAN, 5));\n    assert(!validate_lowest_card_comparator_than_x(hand, LESS_THAN, 3));\n}\n\n#[test]\nfn test_condition_10_lowest_greater_than() {\n    let hand = Hand {\n        card1_value: 7,\n        card1_suit: 1,\n        card2_value: 10,\n        card2_suit: 2,\n        card3_value: 9,\n        card3_suit: 3,\n    };\n    // Lowest is 7, should be greater than 5\n    assert(validate_lowest_card_comparator_than_x(hand, GREATER_THAN, 5));\n    assert(!validate_lowest_card_comparator_than_x(hand, GREATER_THAN, 7));\n}\n\n#[test]\nfn test_condition_10_lowest_equal_to() {\n    let hand = Hand {\n        card1_value: 11,\n        card1_suit: 1,\n        card2_value: 2,\n        card2_suit: 2,\n        card3_value: 6,\n        card3_suit: 3,\n    };\n    // Lowest is 2\n    assert(validate_lowest_card_comparator_than_x(hand, EQUAL_TO, 2));\n    assert(!validate_lowest_card_comparator_than_x(hand, EQUAL_TO, 3));\n}\n\n// Test hand commitment verification\n#[test]\nfn test_hand_commitment() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: 1,\n        card2_value: 10,\n        card2_suit: 2,\n        card3_value: 13,\n        card3_suit: 3,\n    };\n\n    let card1 = pack_card(5, 1);\n    let card2 = pack_card(10, 2);\n    let card3 = pack_card(13, 3);\n\n    let temp = poseidon::bn254::hash_2([card1, card2]);\n    let commitment = poseidon::bn254::hash_2([temp, card3]);\n\n    verify_hand_commitment(hand, commitment);\n}\n\n// Test full circuit integration\n#[test]\nfn test_full_circuit_condition_1() {\n    let hand = Hand {\n        card1_value: 10,\n        card1_suit: 1,\n        card2_value: 5,\n        card2_suit: 2,\n        card3_value: 8,\n        card3_suit: 3,\n    };\n\n    let card1 = pack_card(10, 1);\n    let card2 = pack_card(5, 2);\n    let card3 = pack_card(8, 3);\n\n    let temp = poseidon::bn254::hash_2([card1, card2]);\n    let commitment = poseidon::bn254::hash_2([temp, card3]);\n\n    // Sum is 23, greater than 20\n    main(\n        hand,\n        1,\n        commitment,\n        CONDITION_CARDS_SUM_COMPARATOR_THAN_X,\n        GREATER_THAN,\n        20,\n        0,\n    );\n}\n\n#[test]\nfn test_full_circuit_condition_3() {\n    let hand = Hand {\n        card1_value: 5,\n        card1_suit: HEARTS,\n        card2_value: 10,\n        card2_suit: HEARTS,\n        card3_value: 3,\n        card3_suit: CLUBS,\n    };\n\n    let card1 = pack_card(5, HEARTS);\n    let card2 = pack_card(10, HEARTS);\n    let card3 = pack_card(3, CLUBS);\n\n    let temp = poseidon::bn254::hash_2([card1, card2]);\n    let commitment = poseidon::bn254::hash_2([temp, card3]);\n\n    // 2 cards of HEARTS\n    main(\n        hand,\n        1,\n        commitment,\n        CONDITION_EXACTLY_X_CARDS_OF_SUIT_Y,\n        0,\n        2,\n        HEARTS,\n    );\n}\n",
      "path": "/Users/damianalejandropinones/Documents/temp/liars-proof/circuit/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": ["directive_invert", "directive_integer_quotient"]
}
